<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {%- include head.html -%}

  <body>

    {%- include header.html -%}

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
          {{ content }}
          <div id="container"></div>
      </div>
    </main>

    {%- include footer.html -%}

  </body>
  <div id="container"></div>

  <script>
      const repo = "repos/luabagg/learning-data-science-ufsm"
      const baseFolder = "docs"
      const baseTreeURL = `https://api.github.com/${repo}/git/trees`
      const baseFolderIndex = ""

      // Returns default text for no content.
      function getNoContentText() {
          return "<p>Lista de conteúdos vazia :(</p>"
      }

      // Split method that only splits the separator's last occurance.
      function splitLastIndex(item, separator) {
          const pos = item.lastIndexOf(separator)

          return pos == -1 ? [item] :
              [
                  item.slice(0, pos),
                  item.slice(pos + 1)
              ]
      }

      // Creates a map of the folder and its files -> { folder: [files html links]}.
      function createListMap(path, treeData) {
          let listMap = {}

          for (let item of treeData) {
              if (item.type != "blob") {
                  continue
              }

              const splitted = splitLastIndex(item.path, "/")
              if (splitted.length == 1) {
                  folder = baseFolderIndex
                  name = item.path
              } else if (splitted.length == 2) {
                  folder = splitted[0]
                  name = splitted[1]
              } else {
                  continue
              }
              if (listMap[folder] == undefined) {
                  listMap[folder] = []
              }
              listMap[folder].push(
                  `<li><a href="${path}/${item.path}">${name}</a></li>`
              )
          }

          return listMap
      }

      // Formats the tag according to the folder's depth.
      function getTitleTag(title, depth) {
          const startsIn = 3
          tagNumber = depth + startsIn
          if (tagNumber > 6) {
              return `<p><strong>${title}</strong></p>`
          }

          return `<h${tagNumber}>${title}</h${tagNumber}>`
      }

      // Go through each folder and checks if it has a parent folder by splitting the last index.
      // If it does, calls itself until base folder is reached. Then, appends the html in order.
      function writeListRecursively(folderName, listMap) {
          const splitted = splitLastIndex(folderName, "/")
          const depth = splitted.length - 1

          let htmlString = ""
          if (depth > 0) {
              htmlString += writeListRecursively(splitted[0], listMap)
          }

          if (folderName) {
              htmlString += getTitleTag(splitted[depth], depth)
          }

          htmlString += "<ul>"
          for (let list of listMap[folderName]) {
              htmlString += list;
          }
          htmlString += "</ul>"



          return htmlString
      }

      // Returns all subfolders in the max depth
      // i.e ["asd", "asd/asd"] returns ["asd/asd"]
      function getSubFolders(treeData) {
          let subFolders = [baseFolderIndex]
          for (let node of treeData) {
              if (node.type != "tree") {
                  continue
              }
              subFolders.push(node.path)
          }

          const totalLen = subFolders.length
          const filtered = []

          for (i = 0; i < totalLen; i++) {
              let subFolder = subFolders[i]

              exists = false
              for (k = 0; k < totalLen; k++) {
                  if (i == k) {
                      continue
                  }
                  folderToCheck = subFolders[k]
                  father = splitLastIndex(folderToCheck, "/")
                  if (father[0] == subFolder) {
                      exists = true
                  }
              }

              if (!exists) {
                  filtered.push(subFolder)
              }
          }

          return filtered
      }

      // Traverses the subFolders starting by the base folder (defined as "").
      // Then appends the html of each subfolder.
      function buildHtml(treeData, listMap) {
          const subFolders = getSubFolders(treeData)

          let htmlString = ""
          for (let folderName of subFolders) {
              htmlString += writeListRecursively(folderName, listMap)
          }

          if (!htmlString) {
              return getNoContentText()
          }

          return htmlString
      }

      // Initializes the requests to GitHub's API.
      (async () => {
          const response = await fetch(`https://api.github.com/${repo}/contents/${baseFolder}`);
          if (response.status != 200) {
              return document.getElementById("container").innerHTML = "<p>API do GitHub não está OK :(</p>";
          }

          const data = await response.json();

          // Iterate through the directories listed in $baseFolder

          htmlString = ""
          for (let dirs of data) {
              if (dirs.type != "dir") {
                  continue
              }
              htmlString += `<h2>${dirs.name}</h2>`

              // Get directory info recursively
              const treeResponse = await fetch(`${baseTreeURL}/${dirs.sha}?recursive=1`);
              if (treeResponse.status != 200) {
                  continue
              }

              const treeData = await treeResponse.json();
              if (!treeData.tree) {
                  htmlString += getNoContentText()
                  continue
              }

              htmlString += buildHtml(
                  treeData.tree,
                  createListMap(dirs.path, treeData.tree)
              )
          }
          if (!htmlString) {
              return "<p>Lista de conteúdos vazia :(</p>"
          }

          document.getElementById("container").innerHTML = htmlString;
      })()
  </script>

</html>